import java.lang.reflect.GenericArrayType
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Type
import java.lang.reflect.TypeVariable
import java.lang.reflect.WildcardType
import java.util.stream.Collectors
import java.util.stream.Stream
import Gradle.Common

plugins {
    id 'java'
}

Common.context(this) {
    Common.construct()
}

dependencies {

}

context(this) {
    forwardTask("Library", { it.group == "library" })
}

def that = this
context(this) {
    scriptImport from('std$Common'), being('common')
    scriptImport from('std$Scripting'), being('scripting')
    scriptImport from('std$ClassUtils'), being('classutils')
    scriptImport from('std$KotlinClosureUtils'), being('kclosure')
    Object initContext = common.__INTERNAL_Gradle$Common_initContext
    HashMap scripts = scripting.__INTERNAL_Gradle$DynamicScripting$Scripting_scripts
    def importIfNotExist = { from, being ->
        try {
            def variable = that."${being.user}"
            if(variable != null) return variable
        } catch(Exception ignored) {}
        scriptImport from, being
        return that."${being.user}"
    }
    def parseGenericString
    def parseClassArrayString
    def parseWildcardString
    def parseTypeVariableString
    def parseGenericArrayString
    parseGenericString = { Type type, Map<String, String> generics = null, boolean allowPrimitive = true ->
        if(type instanceof Class) return parseClassArrayString(type, generics, allowPrimitive)
        if(type instanceof ParameterizedType) return "${parseGenericString(type.rawType, generics, false)}<${Stream.of(type.actualTypeArguments).map { parseGenericString(it, generics, false) }.collect(Collectors.joining(", "))}>"
        if(type instanceof WildcardType) return parseWildcardString(type, generics)
        if(type instanceof TypeVariable) return parseTypeVariableString(type, generics)
        if(type instanceof GenericArrayType) return parseGenericArrayString(type, generics)
        throw new Error("Invalid type: $type of class ${type.class}")
    }
    parseClassArrayString = { Class<?> type, Map<String, String> generics = null, boolean allowPrimitive ->
        if(type.isArray()) return parseGenericString(type.componentType, generics, true) + "[]"
        else return type.isPrimitive() && !allowPrimitive ? classutils.primitiveToBoxed.get(type).simpleName.toString() : type.simpleName.toString()
    }
    parseWildcardString = { WildcardType type, Map<String, String> generics ->
        Type[] lowerBounds = type.lowerBounds
        Type[] bounds = lowerBounds
        if(lowerBounds.length == 0) {
            Type[] upperBounds = type.getUpperBounds()
            if(upperBounds.length == 0 || upperBounds[0] == Object.class)
                return "?"
            bounds = upperBounds
        }
        return "? ${bounds == lowerBounds ? "super" : "extends"} ${Stream.of(bounds).map { parseGenericString(it, generics, false) }.collect(Collectors.joining(" & "))}"
    }
    parseTypeVariableString = { TypeVariable type, Map<String, String> generics ->
        String name = type.name
        Type[] bounds = type.bounds
        String generated = bounds.length == 0 || bounds[0] == Object.class ? name :
                "${name} extends ${Stream.of(bounds).map { parseGenericString(it, generics, false) }.collect(Collectors.joining(" & "))}"
        generics.put(name, generated)
        return name
    }
    parseGenericArrayString = { GenericArrayType type, Map<String, String> generics ->
        return parseGenericString(type.genericComponentType, generics, true) + "[]"
    }
    Stream.of(scripts.values().toArray()).filter { it.context == initContext }.forEach { script ->
        println "public class ${script.file.name.substring("std\$".length())} {"
        Stream.of(script.exports.toArray()).forEach { export ->
//            if(!export.being.startsWith("__INTERNAL_")) return
//            linfo export.being
            Stream.of(export.what.toArray()).forEach { closure ->
                Stream.of(closure.overloads.toArray()).forEach { overload ->
                    String klass = overload.class.simpleName
                    if(klass.startsWith("KProperty")) {
                        def property = overload.property
                        def name = property.name
                        def generics = mutableMapOf()
                        def returnType = parseGenericString(property.returnType.javaType, generics, true)
                        def returnTypeGeneric = parseGenericString(property.returnType.javaType, generics, false)
                        def genericsDecl = generics.size() != 0 ? " <${generics.values().stream().collect(Collectors.joining(", "))}>" : ""
//                        lwarn name
                        println "\tpublic static$genericsDecl $returnType get${name.substring(0, 1).toUpperCase() + name.substring(1)}() {"
                        println "\t\treturn ($returnTypeGeneric) ((GroovyObject) getContext().that).getProperty(\"${export.being}\");"
                        println "\t}"
                    }
                    if(klass.startsWith("KMutableProperty")) {
                        def property = overload.property
                        def name = property.name
                        def generics = mutableMapOf()
                        def returnType = parseGenericString(property.returnType.javaType, generics, true)
//                        def returnTypeGeneric = parseGenericString(property.returnType.javaType, generics, false)
                        def genericsDecl = generics.size() != 0 ? " <${generics.values().stream().collect(Collectors.joining(", "))}>" : ""
//                        lwarn name
                        println "\tpublic static$genericsDecl void set${name.substring(0, 1).toUpperCase() + name.substring(1)}($returnType value) {"
                        println "\t\t((GroovyObject) getContext().that).setProperty(\"${export.being}\"), value);"
                        println "\t}"
                    }
                    // Method wrapped in property
                    if(klass == "KLambdaOverload" && closure.overloads.size() == 1) {
                        def importedScript = importIfNotExist from(script.file), being(script.file.name)
                        def functionClosure = importedScript."${export.being}"
                        Stream.of(functionClosure.overloads.toArray()).forEach { funOverload ->
                            String klass2 = funOverload.class.simpleName
                            if(klass2.startsWith("KFunction")) {
                                def function = funOverload.function
                                def generics = mutableMapOf()
                                def parameters = Stream.of(funOverload.kParameters).filter { it.kind.toString() != "INSTANCE" }
                                        .map { "${parseGenericString(it.type.javaType, generics)} ${it.name}" }.collect(Collectors.joining(", "))
                                def parametersName = Stream.of(funOverload.kParameters).filter { it.kind.toString() != "INSTANCE" }
                                        .map { it.name }.collect(Collectors.joining(", "))
                                def name = function.name
                                def returnType = parseGenericString(function.returnType.javaType, generics, true)
                                def returnTypeGeneric = parseGenericString(function.returnType.javaType, generics, false)
                                def genericsDecl = generics.size() != 0 ? " <${generics.values().stream().collect(Collectors.joining(", "))}>" : ""
//                                lwarn name
                                println "\tpublic static$genericsDecl $returnType $name($parameters) {"
                                println "\t\treturn ((Closure<$returnTypeGeneric>) ((GroovyObject) getContext().that).getProperty(\"${export.being}\")).call($parametersName);"
                                println "\t}"
                            }
                        }
//                        def defaultOverload = kclosure.doOverloading(functionClosure.overloads, arrayOf())
//                        println "public static "
                    }
//                    llog klass
//                    llog overload
                }
            }
        }
        println "}"
    }
//    common.addOnConfigFinished(1) {
//        Stream.of(scripts.values().toArray()).filter { it.context == initContext }.forEach { llog it.id }
//        Stream.of(scripts.values().toArray()).forEach { llog it.id }
//    }
//    common.__INTERNAL_Common_groovyKotlinCaches.forEach { llog it.ownerKotlinClass }
//    common.metaClass.properties.forEach { llog it.name }
}
