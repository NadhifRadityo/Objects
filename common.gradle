import org.gradle.api.internal.project.ProjectInternal
import org.gradle.internal.logging.progress.ProgressLogger
import org.gradle.internal.logging.progress.ProgressLoggerFactory
import org.gradle.internal.logging.text.StyledTextOutput
import org.gradle.internal.logging.text.StyledTextOutputFactory
import org.gradle.launcher.daemon.server.scaninfo.DaemonScanInfo

import java.lang.management.ManagementFactory
import java.nio.file.Paths
import java.util.function.Consumer
import java.util.stream.Collectors
import java.util.stream.Stream
import java.util.Optional

class $ {
	static def $this
	static File mainModuleDir
	static List<Settings> $settings = new LinkedList<Object>()
	static List<Runnable> onBuildFinished = new ArrayList<>()
	static ThreadLocal<LinkedList<Object>> contextStack = ThreadLocal.withInitial(LinkedList::new)
	static ThreadLocal<LinkedList<ImportInfo>> importStack = ThreadLocal.withInitial(LinkedList::new)
	static Map<String, List<ImportInfo>> importedScripts = new HashMap<>()
	static Map<String, Consumer<ImportInfo>> importActions = new HashMap<>()

	static void context(def $that, Runnable callback) {
		LinkedList<Object> stack = contextStack.get()
		stack.addLast($that)
		try {
			callback.run()
		} catch(Throwable e) {
			throw new Error(e)
		} finally {
			def last = stack.removeLast()
			if($that != last)
				throw new IllegalStateException('Must not happen')
		}
	}
	static Object last_context() {
		LinkedList<Object> stack = contextStack.get()
		if(stack.size() == 0)
			throw new IllegalStateException('context is not available')
		return stack.getLast()
	}
	static apply_settings() {
		def $that = last_context()
		if(!utils.is_settings())
			throw new IllegalStateException('This function is only available on settings phase.')
		Object[] includedFrom = utils.build_included_from($that)
		if(includedFrom.length > 0)
			return
		if($.mainModuleDir != null)
			throw new IllegalStateException('main module dir only can be set once.')
		$.mainModuleDir = $this.rootDir
	}

	static class ImportInfo {
		Consumer<ImportInfo>[] actions
		IncludedBuild build
		File scriptFile
		String scriptId
		Object importContext
		Object context
		List<Runnable> scriptInits
		List<Runnable> scriptDeinits
		Map<String, Object> exports
	}
	static void require(Object... scripts) {
		def $that = last_context()
		LinkedList<ImportInfo> stack = importStack.get()
		ImportInfo lastImport = stack.size() > 0 ? stack.getLast() : null
		for(Object script : scripts) {
			Consumer<ImportInfo>[] actions = null
			IncludedBuild build = lastImport?.build
			if(script instanceof List) {
				actions = script.get(0) as Consumer<ImportInfo>[]
				script = script.get(1)
			}
			if(script instanceof String && script.contains(':')) {
				int split = script.indexOf(':')
				String buildName = script.substring(0, split)
				String path = script.substring(split + 1)
				build = $that.gradle.includedBuild(buildName)
				script = new File(build.projectDir, path)
			} else if(build != null) {
				if(script instanceof String && script.startsWith('/'))
					script = new File(build.projectDir, script)
				else if(script instanceof String)
					script = new File($that.buildscript.sourceFile.getParentFile(), script)
				else if(!(script instanceof File))
					throw new IllegalArgumentException('Unsupported argument type')
			} else if(script instanceof String && script.startsWith('/'))
				script = new File($that.rootDir, script)
			else script = $that.file(script)
			File scriptFile = script as File
			String scriptFilePath = scriptFile.getCanonicalPath()
			String scriptFileName = scriptFile.getName()
			int scriptFileNameSplit = scriptFileName.lastIndexOf('.')
			String scriptId = scriptFileNameSplit == -1 ? scriptFileName :
					scriptFileName.substring(0, scriptFileNameSplit)
			for(Map.Entry<String, List<ImportInfo>> entry : importedScripts.entrySet()) {
				String filePath = entry.getKey()
				List<ImportInfo> anotherImports = entry.getValue()
				if(scriptFilePath == filePath) continue
				for(ImportInfo anotherImport : anotherImports) {
					if(scriptId != anotherImport.scriptId) continue
					throw new Error("Duplicate gradle script id \"$scriptId\", another " +
							"import is from \"${anotherImport.scriptFile.getCanonicalPath()}\"")
				}
			}
			List<ImportInfo> importsHistory = get_imports_history(scriptFilePath)
			ImportInfo importInfo = new ImportInfo()
			importInfo.actions = actions
			importInfo.build = build
			importInfo.scriptFile = scriptFile
			importInfo.scriptId = scriptId
			importInfo.importContext = $that
			importInfo.context = importsHistory.size() > 0 ? importsHistory.get(0).context : null
			importInfo.scriptInits = new LinkedList<Runnable>()
			importInfo.scriptDeinits = new LinkedList<Runnable>()
			importInfo.exports = importsHistory.size() > 0 ? importsHistory.get(0).exports : new HashMap<>()
			def preCheck = {
				println "Already imported? ${scriptFilePath} -> ${importsHistory.size()} (${importInfo.exports.size()})"
				return importsHistory.size() == 0
			}
			def postCheck = {
				if(importInfo.context == null)
					throw new IllegalStateException('Imported script does not call scriptApply')
				println "Already imported? ${scriptFilePath} -> ${importsHistory.size()} (${importInfo.exports.size()})"
				for(Map.Entry<String, Object> entry : importInfo.exports)
					$that.ext.set(entry.getKey(), entry.getValue())
				return importsHistory.add(importInfo)
			}
			def preAction = {
				stack.addLast(importInfo)
				if(actions != null && actions[0] != null)
					actions[0].accept(importInfo)

				LinkedList<Map<String, Object>> temp = $that.ext.find('__INTERNAL__EXT__TEMP__STACK__')
				if(temp == null) {
					temp = new LinkedList()
					$that.ext.set('__INTERNAL__EXT__TEMP__STACK__', temp)
				}
				Map<String, Object> extTemp = new LinkedHashMap<String, Object>()
				temp.addLast(extTemp)
				def __PUSH__EXT__TEMP__STACK__ = { String key, Object value ->
					extTemp.put(key, $that.ext.find(key))
					$that.ext.set(key, value)
					if(importInfo.context != null)
						importInfo.context.ext.set(key, value)
				}
				def __POP__EXT__TEMP__STACK__ = { String key ->
					Object value = extTemp.remove(key)
					$that.ext.set(key, value)
					if(importInfo.context != null)
						importInfo.context.ext.set(key, value)
				}
				__PUSH__EXT__TEMP__STACK__('__PUSH__EXT__TEMP__STACK__', __PUSH__EXT__TEMP__STACK__)
				__PUSH__EXT__TEMP__STACK__('__POP__EXT__TEMP__STACK__', __POP__EXT__TEMP__STACK__)
				__PUSH__EXT__TEMP__STACK__('contains_flag', { String flag ->
					return $that.ext.find("${scriptId}_${flag}") != null
				})
				__PUSH__EXT__TEMP__STACK__('scriptInit', { Runnable callback ->
					importInfo.scriptInits.add(callback)
					callback.run()
				})
				__PUSH__EXT__TEMP__STACK__('scriptDeinit', { Runnable callback ->
					importInfo.scriptDeinits.add(callback)
					onBuildFinished.add(callback)
				})
			}
			def postAction = {
				LinkedList<Map<String, Object>> temp = $that.ext.get('__INTERNAL__EXT__TEMP__STACK__')
				Map<String, Object> extTemp = temp.removeLast()
				def __POP__EXT__TEMP__STACK__ = $that.ext.get('__POP__EXT__TEMP__STACK__')
				List<String> reversedKey = extTemp.keySet().stream().collect(Collectors.toList())
				Collections.reverse(reversedKey)
				for(String key : reversedKey)
					__POP__EXT__TEMP__STACK__(key)
				if(temp.size() == 0)
					$that.ext.set('__INTERNAL__EXT__TEMP__STACK__', null)

				if(actions != null && actions[1] != null)
					actions[1].accept(importInfo)
				ImportInfo lastImportInfo = stack.removeLast()
				if(importInfo != lastImportInfo)
					throw new IllegalStateException('Must not happen')
			}
			boolean preCheckResult = preCheck()
			preAction()
			if(preCheckResult)
				$that.apply from: $that.relativePath(scriptFile)
			Consumer<ImportInfo> importAction = importActions.get(scriptFilePath)
			if(importAction != null)
				importAction.accept(importInfo)
			postAction()
			postCheck()
		}
	}
	static void export(String key, Object value) {
		LinkedList<ImportInfo> stack = importStack.get()
		ImportInfo lastImport = stack.size() > 0 ? stack.getLast() : null
		if(lastImport == null) return
		lastImport.exports.put(key, value)
		$this.ext.set(key, value)
	}
	static List<ImportInfo> get_imports_history(String scriptFilePath) {
		List<ImportInfo> importsHistory = importedScripts.get(scriptFilePath)
		if(importsHistory == null) {
			importsHistory = new ArrayList<>()
			importedScripts.put(scriptFilePath, importsHistory)
		}
		return importsHistory
	}
	static void mark_imported(String scriptFilePath, def context, Runnable callback) {
		LinkedList<ImportInfo> stack = importStack.get()
		List<ImportInfo> importsHistory = get_imports_history(scriptFilePath)
		ImportInfo importInfo = new ImportInfo()
		importInfo.context = context
		importInfo.exports = new HashMap<>()
		stack.addLast(importInfo)
		callback.run()
		stack.removeLast()
		importsHistory.add(importInfo)
	}
	static void add_import_action(File file, Consumer<ImportInfo> action) {
		importActions.put(file.getCanonicalPath(), action)
	}
	static void remove_import_action(File file) {
		importActions.remove(file.getCanonicalPath())
	}
	static void __only_require() {
		throw new IllegalArgumentException('This function is only available when imported using "require"')
	}
	static void __PUSH__EXT__TEMP__STACK__(String key, Object value) {
		__only_require()
	}
	static void __POP__EXT__TEMP__STACK__(String key, Object value) {
		__only_require()
	}

	static Consumer<ImportInfo>[] import_flags(String... flags) {
		return new Consumer<ImportInfo>[] {
			{ ImportInfo info -> for(String flag : flags) info.importContext.ext.set("${info.scriptId}_${flag}", true) },
			{ ImportInfo info -> for(String flag : flags) info.importContext.ext.set("${info.scriptId}_${flag}", null) }
		}
	}
	static Consumer<ImportInfo>[] flags_export_functions_only() {
		return import_flags('export_functions_only')
	}
	static boolean contains_flag(String flag) {
		if(!utils.is_settings())
			__only_require()
		return $this.ext.find("settings_${flag}") != null
	}

	static void scriptApply() {
		def $that = last_context()
		LinkedList<ImportInfo> stack = importStack.get()
		ImportInfo lastImport = stack.size() > 0 ? stack.getLast() : null
		if(lastImport != null)
			lastImport.context = $that
	}
	static void scriptInit(Runnable callback) {
		if(!utils.is_settings())
			__only_require()
		callback.run()
	}
	static void scriptDeinit(Runnable callback) {
		if(!utils.is_settings())
			__only_require()
		$.onBuildFinished.add(callback)
	}

	static void default_group_version() {
		def $that = last_context()
		$that.group $that.rootProject.group
		$that.version $that.rootProject.version
	}
	static void __default_import_action(ImportInfo info) {
		def $that = info.importContext
		if($that.extensions.findByType(EXPORT_GLOBAL_FUNCTION) == null)
			$that.extensions.create('$_', EXPORT_GLOBAL_FUNCTION)
		if(!$that.contains_flag('export_functions_only')) {
			default_group_version()
			if(!logger.logger_available())
				logger.logger_init()
			if(!progress.progress_available())
				progress.progress_init()
		}
	}
}
class logger {
	static def $this
	static StyledTextOutputFactory factory
	static Map<Integer, StyledTextOutput> instances

	static void logger_init() {
		factory = utils.as_service(StyledTextOutputFactory)
		instances = new HashMap<>()
	}
	static void logger_deinit() {
		factory = null
		instances = null
	}
	static boolean logger_available() {
		return factory != null
	}

//	static void logger_create(Object identifier = null, String loggerCategory) {
//	static void logger_create(Object identifier = null, String loggerCategory, LogLevel logLevel) {
//	static void logger_create(Object identifier = null, Class<?> loggerCategory) {
//	static void logger_create(Object identifier = null, Class<?> loggerCategory, LogLevel logLevel) {
	static void logger_create(Object identifier = null, Object... args) {
		StyledTextOutput instance
		if(args[0] == null && args.length == 1) instance = factory.create(null as String)
		else if(args[0] == null) instance = factory.create(null as String, args[1] as LogLevel)
		else instance = factory.&create.call(args)
		instances.put(System.identityHashCode(identifier), instance)
	}
	static void logger_destroy(Object identifier = null) {
		instances.remove(System.identityHashCode(identifier))
	}
	static StyledTextOutput logger_instance(Object identifier = null) {
		return instances.get(System.identityHashCode(identifier))
	}

	static void __on_print(Object identifier, Consumer<StyledTextOutput> callback) {
		StyledTextOutput instance = logger_instance(identifier)
		if(instance != null) { callback.accept(instance); return }
		logger_create(identifier, Optional.ofNullable(identifier?.toString()).orElse('default'))
		callback.accept(logger_instance(identifier))
	}
//	static void logger_append(Object identifier = null, char c) {
//	static void logger_append(Object identifier = null, CharSequence csq) {
//	static void logger_append(Object identifier = null, CharSequence csq, int start, int end) {
	static void logger_append(Object identifier = null, Object... args) {
		__on_print(identifier) { it.&append.call(args) }
	}
	static void logger_style(Object identifier = null, StyledTextOutput.Style style) {
		__on_print(identifier) { it.style(style) }
	}
	static void logger_text(Object identifier = null, Object text) {
		__on_print(identifier) { it.text(text) }
	}
//	static void logger_println(Object identifier = null, Object text) {
//	static void logger_println(Object identifier = null) {
	static void logger_println(Object identifier = null, Object... args) {
		__on_print(identifier) { it.&println.call(args) }
	}
	static void logger_format(Object identifier = null, String pattern, Object... args) {
		__on_print(identifier) { it.format(pattern, args) }
	}
	static void logger_formatln(Object identifier = null, String pattern, Object... args) {
		__on_print(identifier) { it.formatln(pattern, args) }
	}
	static void logger_exception(Object identifier = null, Throwable throwable) {
		__on_print(identifier) { it.exception(throwable) }
	}

	static escapeCodes = Stream.of(('fblack|30 fred|31 fgreen|32 fyellow|33 fblue|34 fmagenta|35 fcyan|36 fwhite|37 fbblack|90 fbred|91 fbgreen|92 fbyellow|93 fbblue|94 fbmagenta|95 fbcyan|96 fbwhite|97 freset|39 ' +
					'bblack|40 bred|41 bgreen|42 byellow|43 bblue|44 bmagenta|45 bcyan|46 bwhite|47 bbblack|100 bbred|101 bbgreen|102 bbyellow|103 bbblue|104 bbmagenta|105 bbcyan|106 bbwhite|107 breset|49').split(' '))
					.map(v -> v.split('\\|')).collect(Collectors.<String[], String, String>toMap(v -> v[0], v -> "\033[${v[1]}m"))
	static Object[] injectLog = new Object[] { 'fwhite' }
	static Object[] injectInfo = new Object[] { 'fbgreen' }
	static Object[] injectDebug = new Object[] { 'fbblack' }
	static Object[] injectWarn = new Object[] { 'fyellow' }
	static Object[] injectError = new Object[] { 'fred' }

	static Object __identify_object(Object obj) {
		if(obj instanceof Throwable) {
			StringWriter stringWriter = new StringWriter()
			PrintWriter printWriter = new PrintWriter(stringWriter)
			obj.printStackTrace(printWriter)
			return stringWriter.toString()
		}
		return obj
	}
	static void println_impl(Object... args) {
		for(int i = 0; i < args.length; i++) {
			Object arg = args[i]
			Object identifiedArg = __identify_object(arg)
			String escapeCode = escapeCodes.get(identifiedArg)
			args[i] = escapeCode != null ? escapeCode : identifiedArg
		}
		String[] stringArgs = Stream.of(args).map(Object::toString).toArray(String[]::new)
		String compiledString = String.join('', stringArgs)
		compiledString += escapeCodes.get('freset')
		compiledString += escapeCodes.get('breset')
		if(!logger_available()) { println compiledString; return }
		logger_println(null, compiledString)
	}
	static Object[] __inject_additional(Object[] inject, Object[] args) {
		Object[] newArgs = new Object[args.length + inject.length]
		System.arraycopy(inject, 0, newArgs, 0, inject.length)
		System.arraycopy(args, 0, newArgs, inject.length, args.length)
		return newArgs
	}
	static void plog(Object... args) {
		println_impl(__inject_additional(injectLog, args))
	}
	static void pinfo(Object... args) {
		println_impl(__inject_additional(injectInfo, args))
	}
	static void pdebug(Object... args) {
		println_impl(__inject_additional(injectDebug, args))
	}
	static void pwarn(Object... args) {
		println_impl(__inject_additional(injectWarn, args))
	}
	static void perror(Object... args) {
		println_impl(__inject_additional(injectError, args))
	}
}
class progress {
	static def $this
	static ProgressLoggerFactory factory
	static Map<Integer, ProgressLogger> instances

	static void progress_init() {
		factory = utils.as_service(ProgressLoggerFactory)
		instances = new HashMap<>()
	}
	static void progress_deinit() {
		factory = null
		instances = null
	}
	static boolean progress_available() {
		return factory != null
	}

//	static void progress_create(Object identifier = null, String loggerCategory) {
//	static void progress_create(Object identifier = null, Class<?> loggerCategory) {
//	static void progress_create(Object identifier = null, Class<?> loggerCategory, BuildOperationDescriptor buildOperationDescriptor) {
//	static void progress_create(Object identifier = null, Class<?> loggerCategory, ProgressLogger parent) {
	static void progress_create(Object identifier = null, Object... args) {
		ProgressLogger instance
		if(args[0] == null && args.length == 1) instance = factory.newOperation(null as String)
		else if(args.length == 2 && args[1] == null) instance = factory.newOperation(args[0] as Class, args[1] as ProgressLogger)
		else instance = factory.&newOperation.call(args)
		instances.put(System.identityHashCode(identifier), instance)
	}
	static void progress_destroy(Object identifier = null) {
		instances.remove(System.identityHashCode(identifier))
	}
	static ProgressLogger progress_instance(Object identifier = null) {
		return instances.get(System.identityHashCode(identifier))
	}

	static void __on_start(Object identifier, Consumer<ProgressLogger> callback) {
		ProgressLogger instance = progress_instance(identifier)
		if(instance != null) { callback.accept(instance); return }
		progress_create(identifier, Optional.ofNullable(identifier?.toString()).orElse('default'))
		callback.accept(progress_instance(identifier))
	}
	static void __on_do(Object identifier, Consumer<ProgressLogger> callback) {
		__on_start(identifier, callback)
	}
	static void __on_end(Object identifier, Consumer<ProgressLogger> callback) {
		__on_start(identifier) {
			callback.accept(it)
			progress_destroy(identifier)
		}
	}
//	static void progress_start(Object identifier = null, String description, String status) {
//	static void progress_start(Object identifier = null, String status) {
//	static void progress_start(Object identifier = null) {
	static void progress_start(Object identifier = null, Object... args) {
		__on_start(identifier) { args.length == 2 ? it.&start.call(args) : it.&started.call(args) }
	}
//	static void progress_do(Object identifier = null, String status) {
//	static void progress_do(Object identifier = null, String status, boolean failing) {
	static void progress_do(Object identifier = null, Object... args) {
		__on_do(identifier) { it.&progress.call(args) }
	}
//	static void progress_end(Object identifier = null) {
//	static void progress_end(Object identifier = null, String status, boolean failed) {
	static void progress_end(Object identifier = null, Object... args) {
		__on_end(identifier) { it.&completed.call(args) }
	}
}
class utils {
	static def $this

	static Throwable __invalid_type() {
		throw new Error('Invalid type')
	}
	static Project as_project(Object project) {
		if(project == null) return $this.project
		if(project instanceof Project) return project
		if(project instanceof String) return $this.project(project)
		throw __invalid_type()
	}
	static Task as_task(Object task, Object project = null) {
		if(task instanceof Task) return task
		if(task instanceof String) return as_project(project).tasks.getByName(task)
		throw __invalid_type()
	}
	static <T> T as_service(Class<T> clazz, Object project = null) {
		return (as_project(project) as ProjectInternal).services.get(clazz)
	}
	static boolean is_settings() {
		return $this.hasProperty('settings') && $this.getProperty('settings') instanceof Settings
	}
	static Object current_build_settings() {
		return $.$settings.stream().filter({ it.rootDir == $this.rootDir }).findFirst().get()
	}
	static Object[] build_included_from(def $what) {
		return $.$settings.stream().filter({
			it.startParameter.includedBuilds.stream().filter({ it == $what.rootDir }).count() > 0
		}).toArray()
	}
	static <T> T global_ext_get(String key) {
		return $this.gradle.ext.find(key)
	}
	static <T> void global_ext_set(String key, T object) {
		$this.gradle.ext.set(key, object)
	}
	static void forward_task(Object project, filter, exec = {}) {
		Project project0 = as_project(project)
		project0.tasks.stream().filter(filter).collect(Collectors.<Task, Task, Task>toMap({
			project0.task(it.name) { group = it.group; dependsOn it } }, { it })).forEach(exec)
	}
	static void run_after_another_task(Object tasks, Object project = null) {
		if(tasks instanceof Collection) tasks = tasks.toArray()
		for(int i = 0; i < tasks.length; i++) tasks[i] = as_task(tasks[i], project)
		for(int i = 1; i < tasks.length; i++) tasks[i].mustRunAfter(tasks[i - 1])
	}
	static boolean is_single_use_daemon(Object project = null) {
		return as_service(DaemonScanInfo, project).isSingleUse()
	}
	static boolean is_running_on_debug() {
		return ManagementFactory.getRuntimeMXBean().getInputArguments().stream().filter({ it.indexOf('-agentlib:jdwp') != -1 }).count() > 0
	}
	static boolean is_daemon_probably_unstable(Object project = null) {
		return is_single_use_daemon(project) || is_running_on_debug()
	}
	static File get_relative_file(File from, File what) {
		return Paths.get(from.getCanonicalPath()).relativize(Paths.get(what.getCanonicalPath())).toFile()
	}
	static void purge_thread_local(ThreadLocal threadLocal) {
		Thread.getAllStackTraces().keySet().forEach({ try {
			if(!it.hasProperty('threadLocals')) return
			def threadLocals = it.threadLocals
			if(threadLocals == null) return
			threadLocals.remove(threadLocal)
		} catch(Throwable ignored) { } })
	}
}
{
	$.$this = this
	logger.$this = this
	progress.$this = this
	utils.$this = this
}
if(utils.is_settings()) {
	{
		$.$settings.addLast(this)
		$.add_import_action(buildscript.sourceFile, $.&__default_import_action)
	}
	gradle.buildFinished { BuildResult buildResult ->
		$.$settings.removeLast()
		if(rootDir != $.mainModuleDir) return
		$.remove_import_action(buildscript.sourceFile)

		GradleException exception = new GradleException('Error while running callback')
		Collections.reverse($.onBuildFinished)
		for(Runnable callback : $.onBuildFinished)
			try { callback.run() }
			catch(Throwable e) { exception.addSuppressed(e) }
		$.onBuildFinished.clear()
		utils.purge_thread_local($.contextStack)
		utils.purge_thread_local($.importStack)
		$.importedScripts.clear()
		$.importActions.clear()
		logger.logger_deinit()
		progress.progress_deinit()
		for(Map.Entry<String, Object> entry : ext.getProperties()) {
			String key = entry.getKey()
			if(!key.startsWith('ext_') || !key.endsWith('_$imported')) continue;
			ext.set(key, null)
		}
		$.mainModuleDir = null

		$.$this = null
		logger.$this = null
		progress.$this = null
		utils.$this = null
		if(exception.getSuppressed().length > 0)
			throw exception
	}
} else if($.mainModuleDir == null)
	throw new Error('"mainModuleDir" is not set, define this properties on settings.gradle')

ext {
	CONFIG = [:]
	CONFIG['LIBRARY_SPOTBUGS'] = ['com.github.spotbugs:spotbugs-annotations:4.4.0']
	CONFIG['LIBRARY_COMMONS_LANG'] = ['org.apache.commons:commons-lang3:3.12.0', 'commons-io:commons-io:2.6']
	CONFIG['LIBRARY_JNA'] = ['net.java.dev.jna:jna:5.9.0', 'net.java.dev.jna:jna-platform:5.9.0']
	CONFIG['LIBRARY_ECLIPSE_COLLECTION'] = ['org.eclipse.collections:eclipse-collections:10.4.0', 'org.eclipse.collections:eclipse-collections-api:10.4.0']
	CONFIG['LIBRARY_DEPRECATED'] = ['org.apache.httpcomponents:httpclient:4.5.12', 'net.oneandone.reflections8:reflections8:0.11.7', 'org.jogamp.gluegen:gluegen-rt-main:2.3.1', 'org.json:json:20180813', 'org.apache.commons:commons-pool2:2.8.0']
	CONFIG['LIBRARY_DEFAULT'] = CONFIG['LIBRARY_SPOTBUGS'] + CONFIG['LIBRARY_COMMONS_LANG'] + CONFIG['LIBRARY_DEPRECATED']

	CONFIG['TESTLIBRARY_IMPLEMENTATION'] = 'org.junit.jupiter:junit-jupiter-api:5.7.2'
	CONFIG['TESTLIBRARY_RUNTIME'] = 'org.junit.jupiter:junit-jupiter-engine:5.7.2'
}
$.mark_imported(buildscript.sourceFile.getCanonicalPath(), this) {
	$.export('ext_common_context', $.&context)
	$.export('ext_common_last_context', $.&last_context)
	$.export('ext_common_apply_settings', $.&apply_settings)
	$.export('ext_common_require', $.&require)
	$.export('ext_common_export', $.&export)
	$.export('ext_common_get_imports_history', $.&get_imports_history)
	$.export('ext_common_mark_imported', $.&mark_imported)
	$.export('ext_common_add_import_action', $.&add_import_action)
	$.export('ext_common_remove_import_action', $.&remove_import_action)
	$.export('ext_common___PUSH__EXT__TEMP__STACK__', $.&__PUSH__EXT__TEMP__STACK__)
	$.export('ext_common___POP__EXT__TEMP__STACK__', $.&__POP__EXT__TEMP__STACK__)
	$.export('ext_common_import_flags', $.&import_flags)
	$.export('ext_common_flags_export_functions_only', $.&flags_export_functions_only)
	$.export('ext_common_contains_flag', $.&contains_flag)
	$.export('ext_common_scriptApply', $.&scriptApply)
	$.export('ext_common_scriptInit', $.&scriptInit)
	$.export('ext_common_scriptDeinit', $.&scriptDeinit)
	$.export('ext_common_default_group_version', $.&default_group_version)

	$.export('ext_common$logger_init', logger.&logger_init)
	$.export('ext_common$logger_deinit', logger.&logger_deinit)
	$.export('ext_common$logger_available', logger.&logger_available)
	$.export('ext_common$logger_create', logger.&logger_create)
	$.export('ext_common$logger_destroy', logger.&logger_destroy)
	$.export('ext_common$logger_instance', logger.&logger_instance)
	$.export('ext_common$logger_append', logger.&logger_append)
	$.export('ext_common$logger_style', logger.&logger_style)
	$.export('ext_common$logger_text', logger.&logger_text)
	$.export('ext_common$logger_println', logger.&logger_println)
	$.export('ext_common$logger_format', logger.&logger_format)
	$.export('ext_common$logger_formatln', logger.&logger_formatln)
	$.export('ext_common$logger_exception', logger.&logger_exception)
	$.export('ext_common$println_impl', logger.&println_impl)
	$.export('ext_common$plog', logger.&plog)
	$.export('ext_common$pinfo', logger.&pinfo)
	$.export('ext_common$pdebug', logger.&pdebug)
	$.export('ext_common$pwarn', logger.&pwarn)
	$.export('ext_common$perror', logger.&perror)

	$.export('ext_common$progress_init', progress.&progress_init)
	$.export('ext_common$progress_deinit', progress.&progress_deinit)
	$.export('ext_common$progress_available', progress.&progress_available)
	$.export('ext_common$progress_create', progress.&progress_create)
	$.export('ext_common$progress_destroy', progress.&progress_destroy)
	$.export('ext_common$progress_instance', progress.&progress_instance)
	$.export('ext_common$progress_start', progress.&progress_start)
	$.export('ext_common$progress_do', progress.&progress_do)
	$.export('ext_common$progress_end', progress.&progress_end)

	$.export('ext_common$utils_as_project', utils.&as_project)
	$.export('ext_common$utils_as_task', utils.&as_task)
	$.export('ext_common$utils_as_service', utils.&as_service)
	$.export('ext_common$utils_is_settings', utils.&is_settings)
	$.export('ext_common$utils_current_build_settings', utils.&current_build_settings)
	$.export('ext_common$utils_build_included_from', utils.&build_included_from)
	$.export('ext_common$utils_global_ext_get', utils.&global_ext_get)
	$.export('ext_common$utils_global_ext_set', utils.&global_ext_set)
	$.export('ext_common$utils_forward_task', utils.&forward_task)
	$.export('ext_common$utils_run_after_another_task', utils.&run_after_another_task)
	$.export('ext_common$utils_is_single_use_daemon', utils.&is_single_use_daemon)
	$.export('ext_common$utils_is_running_on_debug', utils.&is_running_on_debug)
	$.export('ext_common$utils_is_daemon_probably_unstable', utils.&is_daemon_probably_unstable)
	$.export('ext_common$utils_get_relative_file', utils.&get_relative_file)
	$.export('ext_common$utils_purge_thread_local', utils.&purge_thread_local)

	// Default
	$.export('context', $.&context)
	$.export('last_context', $.&last_context)
	$.export('apply_settings', $.&apply_settings)
	$.export('require', $.&require)
	$.export('export', $.&export)
	$.export('get_imports_history', $.&get_imports_history)
	$.export('mark_imported', $.&mark_imported)
	$.export('add_import_action', $.&add_import_action)
	$.export('remove_import_action', $.&remove_import_action)
	$.export('__PUSH__EXT__TEMP__STACK__', $.&__PUSH__EXT__TEMP__STACK__)
	$.export('__POP__EXT__TEMP__STACK__', $.&__POP__EXT__TEMP__STACK__)
	$.export('import_flags', $.&import_flags)
	$.export('export_functions_only', $.&flags_export_functions_only)
	$.export('contains_flag', $.&contains_flag)
	$.export('scriptApply', $.&scriptApply)
	$.export('scriptInit', $.&scriptInit)
	$.export('scriptDeinit', $.&scriptDeinit)

	$.export('logger_init', logger.&logger_init)
	$.export('logger_deinit', logger.&logger_deinit)
	$.export('logger_available', logger.&logger_available)
	$.export('logger_create', logger.&logger_create)
	$.export('logger_destroy', logger.&logger_destroy)
	$.export('logger_instance', logger.&logger_instance)
	$.export('logger_append', logger.&logger_append)
	$.export('logger_style', logger.&logger_style)
	$.export('logger_text', logger.&logger_text)
	$.export('logger_println', logger.&logger_println)
	$.export('logger_format', logger.&logger_format)
	$.export('logger_formatln', logger.&logger_formatln)
	$.export('logger_exception', logger.&logger_exception)
	$.export('println_impl', logger.&println_impl)
	$.export('plog', logger.&plog)
	$.export('pinfo', logger.&pinfo)
	$.export('pdebug', logger.&pdebug)
	$.export('pwarn', logger.&pwarn)
	$.export('perror', logger.&perror)

	$.export('progress_init', progress.&progress_init)
	$.export('progress_deinit', progress.&progress_deinit)
	$.export('progress_available', progress.&progress_available)
	$.export('progress_create', progress.&progress_create)
	$.export('progress_destroy', progress.&progress_destroy)
	$.export('progress_instance', progress.&progress_instance)
	$.export('progress_start', progress.&progress_start)
	$.export('progress_do', progress.&progress_do)
	$.export('progress_end', progress.&progress_end)

	$.export('as_project', utils.&as_project)
	$.export('as_task', utils.&as_task)
	$.export('as_service', utils.&as_service)
	$.export('is_settings', utils.&is_settings)
	$.export('current_build_settings', utils.&current_build_settings)
	$.export('build_included_from', utils.&build_included_from)
	$.export('global_ext_get', utils.&global_ext_get)
	$.export('global_ext_set', utils.&global_ext_set)
}

class EXPORT_GLOBAL_FUNCTION {
	def context(Object... args) { return $.&context.call(args) }
	def lastContext(Object... args) { return $.&last_context.call(args) }
	def applySettings(Object... args) { return $.&apply_settings.call(args) }
	def require(Object... args) { return $.&require.call(args) }
	def importFlags(Object... args) { return $.&import_flags.call(args) }
	def flagsExportFunctionsOnly(Object... args) { return $.&flags_export_functions_only.call(args) }
	def containsFlag(Object... args) { return $.&contains_flag.call(args) }
	def scriptApply(Object... args) { return $.&scriptApply.call(args) }
	def scriptInit(Object... args) { return $.&scriptInit.call(args) }
	def scriptDeinit(Object... args) { return $.&scriptDeinit.call(args) }

	def loggerInit(Object... args) { return logger.&logger_init.call(args) }
	def loggerDeinit(Object... args) { return logger.&logger_deinit.call(args) }
	def loggerAvailable(Object... args) { return logger.&logger_available.call(args) }
	def loggerCreate(Object... args) { return logger.&logger_create.call(args) }
	def loggerDestroy(Object... args) { return logger.&logger_destroy.call(args) }
	def loggerInstance(Object... args) { return logger.&logger_instance.call(args) }
	def loggerAppend(Object... args) { return logger.&logger_append.call(args) }
	def loggerStyle(Object... args) { return logger.&logger_style.call(args) }
	def loggerText(Object... args) { return logger.&logger_text.call(args) }
	def loggerPrintln(Object... args) { return logger.&logger_println.call(args) }
	def loggerFormat(Object... args) { return logger.&logger_format.call(args) }
	def loggerFormatln(Object... args) { return logger.&logger_formatln.call(args) }
	def loggerException(Object... args) { return logger.&logger_exception.call(args) }
	def printlnImpl(Object... args) { return logger.&println_impl.call(args) }
	def plog(Object... args) { return logger.&plog.call(args) }
	def pinfo(Object... args) { return logger.&pinfo.call(args) }
	def pdebug(Object... args) { return logger.&pdebug.call(args) }
	def pwarn(Object... args) { return logger.&pwarn.call(args) }
	def perror(Object... args) { return logger.&perror.call(args) }

	def progressInit(Object... args) { return progress.&progress_init.call(args) }
	def progressDeinit(Object... args) { return progress.&progress_deinit.call(args) }
	def progressAvailable(Object... args) { return progress.&progress_available.call(args) }
	def progressCreate(Object... args) { return progress.&progress_create.call(args) }
	def progressDestroy(Object... args) { return progress.&progress_destroy.call(args) }
	def progressInstance(Object... args) { return progress.&progress_instance.call(args) }
	def progressStart(Object... args) { return progress.&progress_start.call(args) }
	def progressDo(Object... args) { return progress.&progress_do.call(args) }
	def progressEnd(Object... args) { return progress.&progress_end.call(args) }

	def forwardTask(Object... args) { return utils.&forward_task.call(args) }
	def runAfterAnotherTask(Object... args) { return utils.&run_after_another_task.call(args) }
	def isSingleUseDaemon(Object... args) { return utils.&is_single_use_daemon.call(args) }
	def isRunningOnDebug(Object... args) { return utils.&is_running_on_debug.call(args) }
	def isDaemonProbablyUnstable(Object... args) { return utils.&is_daemon_probably_unstable.call(args) }
	def getRelativeFile(Object... args) { return utils.&get_relative_file.call(args) }
	def purgeThreadLocal(Object... args) { return utils.&purge_thread_local.call(args) }
}
