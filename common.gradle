import org.gradle.api.internal.project.ProjectInternal
import org.gradle.internal.logging.progress.ProgressLogger
import org.gradle.internal.logging.progress.ProgressLoggerFactory
import org.gradle.internal.logging.text.StyledTextOutput
import org.gradle.internal.logging.text.StyledTextOutputFactory
import org.gradle.launcher.daemon.server.scaninfo.DaemonScanInfo

import java.lang.management.ManagementFactory
import java.nio.file.Paths
import java.util.function.Consumer
import java.util.stream.Collectors
import java.util.stream.Stream
import java.util.Optional

class $ {
	static def $this
	static ThreadLocal<LinkedList<Object>> contextStack = ThreadLocal.withInitial(LinkedList::new)
	static ThreadLocal<LinkedList<ImportInfo>> importStack = ThreadLocal.withInitial(LinkedList::new)
	static Map<String, Consumer<ImportInfo>> importActions = new HashMap<>()

	static void context(def $that, Runnable callback) {
		LinkedList<Object> stack = contextStack.get()
		stack.addLast($that)
		try {
			callback.run()
		} finally {
			def last = stack.removeLast()
			if($that != last)
				throw new IllegalStateException("Must not happen")
		}
	}
	static Object last_context() {
		return contextStack.get().getLast()
	}

	static class ImportInfo {
		Consumer<ImportInfo>[] actions
		IncludedBuild build
		File scriptFile
		String scriptName
		String importedTag
		Object context
	}
	static void require(Object... scripts) {
		def $that = last_context()
		LinkedList<ImportInfo> stack = importStack.get()
		ImportInfo lastImport = stack.size() > 0 ? stack.getLast() : null
		for(Object script : scripts) {
			Consumer<ImportInfo>[] actions = null
			IncludedBuild build = lastImport?.build
			if(script instanceof List) {
				actions = script.get(0) as Consumer<ImportInfo>[]
				script = script.get(1)
			}
			if(script instanceof String && script.contains(':')) {
				int split = script.indexOf(':')
				String buildName = script.substring(0, split)
				String path = script.substring(split + 1)
				build = $that.gradle.includedBuild(buildName)
				script = new File(build.projectDir, path)
			} else if(build != null) {
				if(script instanceof String && script.startsWith('/'))
					script = new File(build.projectDir, script)
				else if(script instanceof String)
					script = new File($that.buildscript.sourceFile.getParentFile(), script)
				else if(!(script instanceof File))
					throw new IllegalArgumentException('Unsupported argument type')
			} else if(script instanceof String && script.startsWith('/'))
				script = new File($that.rootDir, script)
			else script = $that.file(script)
			File scriptFile = script as File
			String scriptFilePath = scriptFile.getCanonicalPath()
			String scriptFileName = scriptFile.getName()
			if(!scriptFileName.endsWith('.gradle')) {
				logger.pwarn "Cannot import file \"$scriptFileName\", extension not valid"
				continue
			}
			String scriptName = scriptFileName.substring(0, scriptFileName.length() - '.gradle'.length())
			String importedTag = "ext_${scriptName}_${'$imported'}"
			Consumer<ImportInfo> importAction = importActions.get(scriptFilePath)
			ImportInfo importInfo = new ImportInfo()
			importInfo.actions = actions
			importInfo.build = build
			importInfo.scriptFile = scriptFile
			importInfo.scriptName = scriptName
			importInfo.importedTag = importedTag
			importInfo.context = $that
			def preCheck = { def $what ->
				Object value = $what.ext.find(importedTag)
				if(!(value instanceof String)) return false
				if(value == scriptFilePath) return true
				throw new Error("Duplicate gradle file name \"$scriptFilePath\", another import is from \"$value\"")
			}
			def postCheck = { def $what ->
				Object value = $what.ext.find(importedTag)
				if(value instanceof String && value == scriptFilePath) return false
				$what.ext.set(importedTag, scriptFilePath)
				return true
			}
			def preActionSingle = { ->
				stack.addLast(importInfo)
				if(actions != null && actions[0] != null)
					actions[0].accept(importInfo)
			}
			def postActionSingle = { ->
				if(actions != null && actions[1] != null)
					actions[1].accept(importInfo)
				ImportInfo lastImportInfo = stack.removeLast()
				if(importInfo != lastImportInfo)
					throw new IllegalStateException("Must not happen")
			}
			def preAction = { def $what ->
				LinkedList<Object> contains_flag_temp = $what.ext.find('contains_flag_temp')
				if(contains_flag_temp == null) {
					contains_flag_temp = new LinkedList()
					$what.ext.set('contains_flag_temp', contains_flag_temp)
				}
				contains_flag_temp.addLast($what.ext.find('contains_flag'))
				$what.ext.set('contains_flag', { String flag ->
					$what.ext.find("${scriptName}_${flag}") != null
				})
			}
			def postAction = { def $what ->
				LinkedList<Object> contains_flag_temp = $what.ext.find('contains_flag_temp')
				Object temp_value = contains_flag_temp.removeLast()
				$what.ext.set('contains_flag', temp_value)
				if(contains_flag_temp.size() == 0)
					$what.ext.set('contains_flag_temp', null)
			}
			boolean preCheckThis = preCheck($this)
			boolean preCheckThat = preCheck($that)
			preActionSingle()
			preAction($this)
			preAction($that)
			if(!preCheckThis && !preCheckThat)
				$that.apply from: $that.relativePath(scriptFile)
			if(importAction != null)
				importAction.accept(importInfo)
			postAction($this)
			postAction($that)
			postActionSingle()
			postCheck($this)
			postCheck($that)
		}
	}
	static void add_import_action(File file, Consumer<ImportInfo> action) {
		importActions.put(file.getCanonicalPath(), action)
	}
	static void remove_import_action(File file) {
		importActions.remove(file.getCanonicalPath())
	}

	static Consumer<ImportInfo>[] import_flags(String... flags) {
		return new Consumer<ImportInfo>[] {
			{ ImportInfo info -> for(String flag : flags) info.context.ext.set("${info.scriptName}_${flag}", true) },
			{ ImportInfo info -> for(String flag : flags) info.context.ext.set("${info.scriptName}_${flag}", null) }
		}
	}
	static Consumer<ImportInfo>[] flags_export_functions_only() {
		return import_flags('export_functions_only')
	}
	static boolean contains_flag(String flag) {
		if(!utils.is_settings())
			throw new IllegalArgumentException('This function is only available when imported using "require"')
		return $this.ext.find("settings_${flag}") != null
	}

	static void default_group_version() {
		def $that = last_context()
		$that.group $that.rootProject.group
		$that.version $that.rootProject.version
	}
	static void __default_import_action(ImportInfo info) {
		def $that = info.context
		if($that.extensions.findByType(EXPORT_GLOBAL_FUNCTION) == null)
			$that.extensions.create('$_', EXPORT_GLOBAL_FUNCTION)
		if(!$that.contains_flag('export_functions_only')) {
			default_group_version()
			if(!logger.logger_available())
				logger.logger_init()
			if(!progress.progress_available())
				progress.progress_init()
		}
	}
}
class logger {
	static def $this
	static StyledTextOutputFactory factory
	static Map<Integer, StyledTextOutput> instances

	static void logger_init() {
		factory = utils.as_service(StyledTextOutputFactory)
		instances = new HashMap<>()
	}
	static void logger_deinit() {
		factory = null
		instances = null
	}
	static boolean logger_available() {
		return factory != null
	}

//	static void logger_create(Object identifier = null, String loggerCategory) {
//	static void logger_create(Object identifier = null, String loggerCategory, LogLevel logLevel) {
//	static void logger_create(Object identifier = null, Class<?> loggerCategory) {
//	static void logger_create(Object identifier = null, Class<?> loggerCategory, LogLevel logLevel) {
	static void logger_create(Object identifier = null, Object... args) {
		StyledTextOutput instance
		if(args[0] == null && args.length == 1) instance = factory.create(null as String)
		else if(args[0] == null) instance = factory.create(null as String, args[1] as LogLevel)
		else instance = factory.&create.call(args)
		instances.put(System.identityHashCode(identifier), instance)
	}
	static void logger_destroy(Object identifier = null) {
		instances.remove(System.identityHashCode(identifier))
	}
	static StyledTextOutput logger_instance(Object identifier = null) {
		return instances.get(System.identityHashCode(identifier))
	}

	static void __on_print(Object identifier, Consumer<StyledTextOutput> callback) {
		StyledTextOutput instance = logger_instance(identifier)
		if(instance != null) { callback.accept(instance); return }
		logger_create(identifier, Optional.ofNullable(identifier?.toString()).orElse('default'))
		callback.accept(logger_instance(identifier))
	}
//	static void logger_append(Object identifier = null, char c) {
//	static void logger_append(Object identifier = null, CharSequence csq) {
//	static void logger_append(Object identifier = null, CharSequence csq, int start, int end) {
	static void logger_append(Object identifier = null, Object... args) {
		__on_print(identifier) { it.&append.call(args) }
	}
	static void logger_style(Object identifier = null, StyledTextOutput.Style style) {
		__on_print(identifier) { it.style(style) }
	}
	static void logger_text(Object identifier = null, Object text) {
		__on_print(identifier) { it.text(text) }
	}
//	static void logger_println(Object identifier = null, Object text) {
//	static void logger_println(Object identifier = null) {
	static void logger_println(Object identifier = null, Object... args) {
		__on_print(identifier) { it.&println.call(args) }
	}
	static void logger_format(Object identifier = null, String pattern, Object... args) {
		__on_print(identifier) { it.format(pattern, args) }
	}
	static void logger_formatln(Object identifier = null, String pattern, Object... args) {
		__on_print(identifier) { it.formatln(pattern, args) }
	}
	static void logger_exception(Object identifier = null, Throwable throwable) {
		__on_print(identifier) { it.exception(throwable) }
	}

	static escapeCodes = Stream.of(('fblack|30 fred|31 fgreen|32 fyellow|33 fblue|34 fmagenta|35 fcyan|36 fwhite|37 fbblack|90 fbred|91 fbgreen|92 fbyellow|93 fbblue|94 fbmagenta|95 fbcyan|96 fbwhite|97 freset|39 ' +
					'bblack|40 bred|41 bgreen|42 byellow|43 bblue|44 bmagenta|45 bcyan|46 bwhite|47 bbblack|100 bbred|101 bbgreen|102 bbyellow|103 bbblue|104 bbmagenta|105 bbcyan|106 bbwhite|107 breset|49').split(' '))
					.map(v -> v.split('\\|')).collect(Collectors.<String[], String, String>toMap(v -> v[0], v -> "\033[${v[1]}m"))
	static Object[] injectLog = new Object[] { 'fwhite' }
	static Object[] injectInfo = new Object[] { 'fbgreen' }
	static Object[] injectDebug = new Object[] { 'fbblack' }
	static Object[] injectWarn = new Object[] { 'fyellow' }
	static Object[] injectError = new Object[] { 'fred' }

	static Object __identify_object(Object obj) {
		if(obj instanceof Throwable) {
			StringWriter stringWriter = new StringWriter()
			PrintWriter printWriter = new PrintWriter(stringWriter)
			obj.printStackTrace(printWriter)
			return stringWriter.toString()
		}
		return obj
	}
	static void println_impl(Object... args) {
		for(int i = 0; i < args.length; i++) {
			Object arg = args[i]
			Object identifiedArg = __identify_object(arg)
			String escapeCode = escapeCodes.get(identifiedArg)
			args[i] = escapeCode != null ? escapeCode : identifiedArg
		}
		String[] stringArgs = Stream.of(args).map(Object::toString).toArray(String[]::new)
		String compiledString = String.join('', stringArgs)
		compiledString += escapeCodes.get('freset')
		compiledString += escapeCodes.get('breset')
		if(!logger_available()) { println compiledString; return }
		logger_println(null, compiledString)
	}
	static Object[] __inject_additional(Object[] inject, Object[] args) {
		Object[] newArgs = new Object[args.length + inject.length]
		System.arraycopy(inject, 0, newArgs, 0, inject.length)
		System.arraycopy(args, 0, newArgs, inject.length, args.length)
		return newArgs
	}
	static void plog(Object... args) {
		println_impl(__inject_additional(injectLog, args))
	}
	static void pinfo(Object... args) {
		println_impl(__inject_additional(injectInfo, args))
	}
	static void pdebug(Object... args) {
		println_impl(__inject_additional(injectDebug, args))
	}
	static void pwarn(Object... args) {
		println_impl(__inject_additional(injectWarn, args))
	}
	static void perror(Object... args) {
		println_impl(__inject_additional(injectError, args))
	}
}
class progress {
	static def $this
	static ProgressLoggerFactory factory
	static Map<Integer, ProgressLogger> instances

	static void progress_init() {
		factory = utils.as_service(ProgressLoggerFactory)
		instances = new HashMap<>()
	}
	static void progress_deinit() {
		factory = null
		instances = null
	}
	static boolean progress_available() {
		return factory != null
	}

//	static void progress_create(Object identifier = null, String loggerCategory) {
//	static void progress_create(Object identifier = null, Class<?> loggerCategory) {
//	static void progress_create(Object identifier = null, Class<?> loggerCategory, BuildOperationDescriptor buildOperationDescriptor) {
//	static void progress_create(Object identifier = null, Class<?> loggerCategory, ProgressLogger parent) {
	static void progress_create(Object identifier = null, Object... args) {
		ProgressLogger instance
		if(args[0] == null && args.length == 1) instance = factory.newOperation(null as String)
		else if(args.length == 2 && args[1] == null) instance = factory.newOperation(args[0] as Class, args[1] as ProgressLogger)
		else instance = factory.&newOperation.call(args)
		instances.put(System.identityHashCode(identifier), instance)
	}
	static void progress_destroy(Object identifier = null) {
		instances.remove(System.identityHashCode(identifier))
	}
	static ProgressLogger progress_instance(Object identifier = null) {
		return instances.get(System.identityHashCode(identifier))
	}

	static void __on_start(Object identifier, Consumer<ProgressLogger> callback) {
		ProgressLogger instance = progress_instance(identifier)
		if(instance != null) { callback.accept(instance); return }
		progress_create(identifier, Optional.ofNullable(identifier?.toString()).orElse('default'))
		callback.accept(progress_instance(identifier))
	}
	static void __on_do(Object identifier, Consumer<ProgressLogger> callback) {
		__on_start(identifier, callback)
	}
	static void __on_end(Object identifier, Consumer<ProgressLogger> callback) {
		__on_start(identifier) {
			callback.accept(it)
			progress_destroy(identifier)
		}
	}
//	static void progress_start(Object identifier = null, String description, String status) {
//	static void progress_start(Object identifier = null, String status) {
//	static void progress_start(Object identifier = null) {
	static void progress_start(Object identifier = null, Object... args) {
		__on_start(identifier) { args.length == 2 ? it.&start.call(args) : it.&started.call(args) }
	}
//	static void progress_do(Object identifier = null, String status) {
//	static void progress_do(Object identifier = null, String status, boolean failing) {
	static void progress_do(Object identifier = null, Object... args) {
		__on_do(identifier) { it.&progress.call(args) }
	}
//	static void progress_end(Object identifier = null) {
//	static void progress_end(Object identifier = null, String status, boolean failed) {
	static void progress_end(Object identifier = null, Object... args) {
		__on_end(identifier) { it.&completed.call(args) }
	}
}
class utils {
	static def $this

	static Throwable __invalid_type() {
		throw new Error('Invalid type')
	}
	static Project as_project(Object project) {
		if(project == null) return $this.project
		if(project instanceof Project) return project
		if(project instanceof String) return $this.project(project)
		throw __invalid_type()
	}
	static Task as_task(Object task, Object project = null) {
		if(task instanceof Task) return task
		if(task instanceof String) return as_project(project).tasks.getByName(task)
		throw __invalid_type()
	}
	static <T> T as_service(Class<T> clazz, Object project = null) {
		return (as_project(project) as ProjectInternal).services.get(clazz)
	}
	static boolean is_settings() {
		return $this.hasProperty('settings') && $this.getProperty('settings') instanceof Settings
	}
	static <T> T global_ext_get(String key) {
		return $this.gradle.ext.get(key)
	}
	static <T> void global_ext_set(String key, T object) {
		$this.gradle.ext.set(key, object)
	}
	static void forward_task(Object project, filter, exec = {}) {
		Project project0 = as_project(project)
		project0.tasks.stream().filter(filter).collect(Collectors.<Task, Task, Task>toMap({
			project0.task(it.name) { group = it.group; dependsOn it } }, { it })).forEach(exec)
	}
	static void run_after_another_task(Object tasks, Object project = null) {
		if(tasks instanceof Collection) tasks = tasks.toArray()
		for(int i = 0; i < tasks.length; i++) tasks[i] = as_task(tasks[i], project)
		for(int i = 1; i < tasks.length; i++) tasks[i].mustRunAfter(tasks[i - 1])
	}
	static boolean is_single_use_daemon(Object project = null) {
		return as_service(DaemonScanInfo, project).isSingleUse()
	}
	static boolean is_running_on_debug() {
		return ManagementFactory.getRuntimeMXBean().getInputArguments().stream().filter({ it.indexOf('-agentlib:jdwp') != -1 }).count() > 0
	}
	static boolean is_daemon_probably_unstable(Object project = null) {
		return is_single_use_daemon(project) || is_running_on_debug()
	}
	static File get_relative_file(File from, File what) {
		return Paths.get(from.getCanonicalPath()).relativize(Paths.get(what.getCanonicalPath())).toFile()
	}
	static void purge_thread_local(ThreadLocal threadLocal) {
		Thread.getAllStackTraces().keySet().forEach({ try {
			if(!it.hasProperty('threadLocals')) return
			def threadLocals = it.threadLocals
			if(threadLocals == null) return
			threadLocals.remove(threadLocal)
		} catch(Throwable ignored) { } })
	}
}
{
	$.$this = this
	logger.$this = this
	progress.$this = this
	utils.$this = this
	$.add_import_action(buildscript.sourceFile, $.&__default_import_action)
}
gradle.buildFinished {
	$.$this = null
	logger.$this = null
	progress.$this = null
	utils.$this = null
	$.remove_import_action(buildscript.sourceFile)
	utils.purge_thread_local($.contextStack)
	utils.purge_thread_local($.importStack)
	$.importActions.clear()
	logger.logger_deinit()
	progress.progress_deinit()
	for(Map.Entry<String, Object> entry : ext.getProperties()) {
		String key = entry.getKey()
		if(!key.startsWith('ext_') || !key.endsWith('_$imported')) continue;
		ext.set(key, null)
	}
}

ext {
	CONFIG = [:]
	CONFIG['LIBRARY_SPOTBUGS'] = ['com.github.spotbugs:spotbugs-annotations:4.4.0']
	CONFIG['LIBRARY_COMMONS_LANG'] = ['org.apache.commons:commons-lang3:3.12.0', 'commons-io:commons-io:2.6']
	CONFIG['LIBRARY_JNA'] = ['net.java.dev.jna:jna:5.9.0', 'net.java.dev.jna:jna-platform:5.9.0']
	CONFIG['LIBRARY_ECLIPSE_COLLECTION'] = ['org.eclipse.collections:eclipse-collections:10.4.0', 'org.eclipse.collections:eclipse-collections-api:10.4.0']
	CONFIG['LIBRARY_DEPRECATED'] = ['org.apache.httpcomponents:httpclient:4.5.12', 'net.oneandone.reflections8:reflections8:0.11.7', 'org.jogamp.gluegen:gluegen-rt-main:2.3.1', 'org.json:json:20180813', 'org.apache.commons:commons-pool2:2.8.0']
	CONFIG['LIBRARY_DEFAULT'] = CONFIG['LIBRARY_SPOTBUGS'] + CONFIG['LIBRARY_COMMONS_LANG'] + CONFIG['LIBRARY_DEPRECATED'];

	CONFIG['TESTLIBRARY_IMPLEMENTATION'] = 'org.junit.jupiter:junit-jupiter-api:5.7.2'
	CONFIG['TESTLIBRARY_RUNTIME'] = 'org.junit.jupiter:junit-jupiter-engine:5.7.2'

	ext_common_$imported = buildscript.sourceFile.getCanonicalPath()
	ext_common_context = $.&context
	ext_common_last_context = $.&last_context
	ext_common_require = $.&require
	ext_common_add_import_action = $.&add_import_action
	ext_common_remove_import_action = $.&remove_import_action
	ext_common_import_flags = $.&import_flags
	ext_common_flags_export_functions_only = $.&flags_export_functions_only
	ext_common_contains_flag = $.&contains_flag
	ext_common_default_group_version = $.&default_group_version

	ext_common$logger_init = logger.&logger_init
	ext_common$logger_deinit = logger.&logger_deinit
	ext_common$logger_available = logger.&logger_available
	ext_common$logger_create = logger.&logger_create
	ext_common$logger_destroy = logger.&logger_destroy
	ext_common$logger_instance = logger.&logger_instance
	ext_common$logger_append = logger.&logger_append
	ext_common$logger_style = logger.&logger_style
	ext_common$logger_text = logger.&logger_text
	ext_common$logger_println = logger.&logger_println
	ext_common$logger_format = logger.&logger_format
	ext_common$logger_formatln = logger.&logger_formatln
	ext_common$logger_exception = logger.&logger_exception
	ext_common$println_impl = logger.&println_impl
	ext_common$plog = logger.&plog
	ext_common$pinfo = logger.&pinfo
	ext_common$pdebug = logger.&pdebug
	ext_common$pwarn = logger.&pwarn
	ext_common$perror = logger.&perror

	ext_common$progress_init = progress.&progress_init
	ext_common$progress_deinit = progress.&progress_deinit
	ext_common$progress_available = progress.&progress_available
	ext_common$progress_create = progress.&progress_create
	ext_common$progress_destroy = progress.&progress_destroy
	ext_common$progress_instance = progress.&progress_instance
	ext_common$progress_start = progress.&progress_start
	ext_common$progress_do = progress.&progress_do
	ext_common$progress_end = progress.&progress_end

	ext_common$utils_as_project = utils.&as_project
	ext_common$utils_as_task = utils.&as_task
	ext_common$utils_as_service = utils.&as_service
	ext_common$utils_is_settings = utils.&is_settings
	ext_common$utils_global_ext_get = utils.&global_ext_get
	ext_common$utils_global_ext_set = utils.&global_ext_set
	ext_common$utils_forward_task = utils.&forward_task
	ext_common$utils_run_after_another_task = utils.&run_after_another_task
	ext_common$utils_is_single_use_daemon = utils.&is_single_use_daemon
	ext_common$utils_is_running_on_debug = utils.&is_running_on_debug
	ext_common$utils_is_daemon_probably_unstable = utils.&is_daemon_probably_unstable
	ext_common$utils_get_relative_file = utils.&get_relative_file
	ext_common$utils_purge_thread_local = utils.&purge_thread_local

	// Default
	context = $.&context
	last_context = $.&last_context
	require = $.&require
	import_flags = $.&import_flags
	export_functions_only = $.&flags_export_functions_only
	contains_flag = $.&contains_flag

	logger_init = logger.&logger_init
	logger_deinit = logger.&logger_deinit
	logger_available = logger.&logger_available
	logger_create = logger.&logger_create
	logger_destroy = logger.&logger_destroy
	logger_instance = logger.&logger_instance
	logger_append = logger.&logger_append
	logger_style = logger.&logger_style
	logger_text = logger.&logger_text
	logger_println = logger.&logger_println
	logger_format = logger.&logger_format
	logger_formatln = logger.&logger_formatln
	logger_exception = logger.&logger_exception
	println_impl = logger.&println_impl
	plog = logger.&plog
	pinfo = logger.&pinfo
	pdebug = logger.&pdebug
	pwarn = logger.&pwarn
	perror = logger.&perror

	progress_init = progress.&progress_init
	progress_deinit = progress.&progress_deinit
	progress_available = progress.&progress_available
	progress_create = progress.&progress_create
	progress_destroy = progress.&progress_destroy
	progress_instance = progress.&progress_instance
	progress_start = progress.&progress_start
	progress_do = progress.&progress_do
	progress_end = progress.&progress_end

	as_project = utils.&as_project
	as_task = utils.&as_task
	as_service = utils.&as_service
	is_settings = utils.&is_settings
	global_ext_get = utils.&global_ext_get
	global_ext_set = utils.&global_ext_set
}

class EXPORT_GLOBAL_FUNCTION {
	def context(Object... args) { return $.&context.call(args) }
	def lastContext(Object... args) { return $.&last_context.call(args) }
	def require(Object... args) { return $.&require.call(args) }
	def importFlags(Object... args) { return $.&import_flags.call(args) }
	def flagsExportFunctionsOnly(Object... args) { return $.&flags_export_functions_only.call(args) }
	def containsFlag(Object... args) { return $.&contains_flag.call(args); }

	def loggerInit(Object... args) { return logger.&logger_init.call(args) }
	def loggerDeinit(Object... args) { return logger.&logger_deinit.call(args) }
	def loggerAvailable(Object... args) { return logger.&logger_available.call(args) }
	def loggerCreate(Object... args) { return logger.&logger_create.call(args) }
	def loggerDestroy(Object... args) { return logger.&logger_destroy.call(args) }
	def loggerInstance(Object... args) { return logger.&logger_instance.call(args) }
	def loggerAppend(Object... args) { return logger.&logger_append.call(args) }
	def loggerStyle(Object... args) { return logger.&logger_style.call(args) }
	def loggerText(Object... args) { return logger.&logger_text.call(args) }
	def loggerPrintln(Object... args) { return logger.&logger_println.call(args) }
	def loggerFormat(Object... args) { return logger.&logger_format.call(args) }
	def loggerFormatln(Object... args) { return logger.&logger_formatln.call(args) }
	def loggerException(Object... args) { return logger.&logger_exception.call(args) }
	def printlnImpl(Object... args) { return logger.&println_impl.call(args) }
	def plog(Object... args) { return logger.&plog.call(args) }
	def pinfo(Object... args) { return logger.&pinfo.call(args) }
	def pdebug(Object... args) { return logger.&pdebug.call(args) }
	def pwarn(Object... args) { return logger.&pwarn.call(args) }
	def perror(Object... args) { return logger.&perror.call(args) }

	def progressInit(Object... args) { return progress.&progress_init.call(args) }
	def progressDeinit(Object... args) { return progress.&progress_deinit.call(args) }
	def progressAvailable(Object... args) { return progress.&progress_available.call(args) }
	def progressCreate(Object... args) { return progress.&progress_create.call(args) }
	def progressDestroy(Object... args) { return progress.&progress_destroy.call(args) }
	def progressInstance(Object... args) { return progress.&progress_instance.call(args) }
	def progressStart(Object... args) { return progress.&progress_start.call(args) }
	def progressDo(Object... args) { return progress.&progress_do.call(args) }
	def progressEnd(Object... args) { return progress.&progress_end.call(args) }

	def forwardTask(Object... args) { return utils.&forward_task.call(args) }
	def runAfterAnotherTask(Object... args) { return utils.&run_after_another_task.call(args) }
	def isSingleUseDaemon(Object... args) { return utils.&is_single_use_daemon.call(args) }
	def isRunningOnDebug(Object... args) { return utils.&is_running_on_debug.call(args) }
	def isDaemonProbablyUnstable(Object... args) { return utils.&is_daemon_probably_unstable.call(args) }
	def getRelativeFile(Object... args) { return utils.&get_relative_file.call(args) }
	def purgeThreadLocal(Object... args) { return utils.&purge_thread_local.call(args) }
}
