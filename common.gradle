import org.gradle.api.internal.project.DefaultProject
import org.gradle.internal.logging.text.StyledTextOutput
import org.gradle.internal.logging.text.StyledTextOutputFactory
import org.gradle.launcher.daemon.server.scaninfo.DaemonScanInfo

import java.lang.management.ManagementFactory
import java.util.function.Consumer
import java.util.stream.Collectors
import java.util.stream.Stream

class $ {
	static def $this
	static Map<String, Consumer<Object>> importActions = new HashMap<>()

	static void default_group_version(def $that) {
		$that.group 'io.github.NadhifRadityo.Objects'
		$that.version 'LATEST'
	}
	static void require(def $that, Object... scripts) {
		for(Object script : scripts) {
			if(script instanceof String && script.startsWith('/'))
				script = new File($that.rootDir, script)
			else script = $that.file(script)
			File scriptFile = script as File
			String scriptFileName = scriptFile.getName()
			if(!scriptFileName.endsWith('.gradle')) {
				$that.pwarn "Cannot import file \"$scriptFileName\", extension not valid"
				continue
			}
			Consumer<Object> importAction = importActions.get(scriptFile.getCanonicalPath())
			if(importAction != null) importAction.accept($that)
			String scriptName = scriptFileName.substring(0, scriptFileName.length() - '.gradle'.length())
			String importedTag = "ext_${scriptName}_${'$imported'}"
			if($this.ext.has(importedTag) || $that.ext.has(importedTag)) continue
			$that.apply from: $that.relativePath(scriptFile)
		}
	}
	static void add_import_action(File file, Consumer<Object> action) {
		importActions.put(file.getCanonicalPath(), action)
	}
	static void remove_import_action(File file) {
		importActions.remove(file.getCanonicalPath())
	}
	static void __default_import_action(def $that) {
		if($that.extensions.findByType(EXPORT_GLOBAL_FUNCTION) == null)
			$that.extensions.create('$_', EXPORT_GLOBAL_FUNCTION)
		if($that.ext.find('export_functions_only') == null) {
			default_group_version($that)
			if(!logger.available())
				logger.create('default')
		}
	}
}
class logger {
	static def $this
	static StyledTextOutput out
	static escapeCodes = Stream.of(('fblack|30 fred|31 fgreen|32 fyellow|33 fblue|34 fmagenta|35 fcyan|36 fwhite|37 fbblack|90 fbred|91 fbgreen|92 fbyellow|93 fbblue|94 fbmagenta|95 fbcyan|96 fbwhite|97 freset|39 ' +
					'bblack|40 bred|41 bgreen|42 byellow|43 bblue|44 bmagenta|45 bcyan|46 bwhite|47 bbblack|100 bbred|101 bbgreen|102 bbyellow|103 bbblue|104 bbmagenta|105 bbcyan|106 bbwhite|107 breset|49').split(' '))
					.map(v -> v.split('\\|')).collect(Collectors.<String[], String, String>toMap(v -> v[0], v -> "\033[${v[1]}m"))
	static Object[] injectLog = new Object[] { 'fwhite' }
	static Object[] injectInfo = new Object[] { 'fbgreen' }
	static Object[] injectDebug = new Object[] { 'fbblack' }
	static Object[] injectWarn = new Object[] { 'fyellow' }
	static Object[] injectError = new Object[] { 'fred' }

	static void create(String logCategory) {
		out = ($this.project as DefaultProject).services.get(StyledTextOutputFactory).create(logCategory)
	}
	static boolean available() {
		return out != null
	}
	static Object __identify_object(Object obj) {
		if(obj instanceof Throwable) {
			StringWriter stringWriter = new StringWriter()
			PrintWriter printWriter = new PrintWriter(stringWriter)
			obj.printStackTrace(printWriter)
			return stringWriter.toString()
		}
		return obj
	}
	static void println_impl(Object... args) {
		for(int i = 0; i < args.length; i++) {
			Object arg = args[i]
			Object identifiedArg = __identify_object(arg)
			String escapeCode = escapeCodes.get(identifiedArg)
			args[i] = escapeCode != null ? escapeCode : identifiedArg
		}
		String[] stringArgs = Stream.of(args).map(Object::toString).toArray(String[]::new)
		String compiledString = String.join('', stringArgs)
		compiledString += escapeCodes.get('freset')
		compiledString += escapeCodes.get('breset')
		if(!available()) { println compiledString; return }
		out.println(compiledString)
	}
	static Object[] __inject_additional(Object[] inject, Object[] args) {
		Object[] newArgs = new Object[args.length + inject.length]
		System.arraycopy(inject, 0, newArgs, 0, inject.length)
		System.arraycopy(args, 0, newArgs, inject.length, args.length)
		return newArgs
	}
	static void plog(Object... args) {
		println_impl(__inject_additional(injectLog, args))
	}
	static void pinfo(Object... args) {
		println_impl(__inject_additional(injectInfo, args))
	}
	static void pdebug(Object... args) {
		println_impl(__inject_additional(injectDebug, args))
	}
	static void pwarn(Object... args) {
		println_impl(__inject_additional(injectWarn, args))
	}
	static void perror(Object... args) {
		println_impl(__inject_additional(injectError, args))
	}
	static void destroy() {
		out = null
	}
}
class utils {
	static def $this

	static Throwable __invalid_type() {
		throw new Error('Invalid type')
	}
	static Project as_project(Object project) {
		if(project == null) return $this.project
		if(project instanceof Project) return project
		if(project instanceof String) return $this.project(project)
		throw __invalid_type()
	}
	static Task as_task(Object task, Object project = null) {
		if(task instanceof Task) return task
		if(task instanceof String) return as_project(project).tasks.getByName(task)
		throw __invalid_type()
	}
	static void forward_task(Object project, filter, exec = {}) {
		Project project0 = as_project(project)
		project0.tasks.stream().filter(filter).collect(Collectors.<Task, Task, Task>toMap({
			project0.task(it.name) { group = it.group; dependsOn it } }, { it })).forEach(exec)
	}
	static void run_after_another_task(Object tasks, Object project = null) {
		if(tasks instanceof Collection) tasks = tasks.toArray()
		for(int i = 0; i < tasks.length; i++) tasks[i] = as_task(tasks[i], project)
		for(int i = 1; i < tasks.length; i++) tasks[i].mustRunAfter(tasks[i - 1])
	}
	static boolean is_single_use_daemon() {
		return ($this.project as DefaultProject).services.get(DaemonScanInfo).isSingleUse()
	}
	static boolean is_running_on_debug() {
		return ManagementFactory.getRuntimeMXBean().getInputArguments().stream().filter({ it.indexOf('-agentlib:jdwp') != -1 }).count() > 0
	}
	static boolean is_daemon_probably_unstable() {
		return is_single_use_daemon() || is_running_on_debug()
	}
}
{
	$.$this = this
	logger.$this = this
	utils.$this = this
	$.importActions.clear()
	$.add_import_action(buildscript.sourceFile, $.&__default_import_action)
	$.__default_import_action(this)
}

ext {
	CONFIG = [:]
	CONFIG['LIBRARY_SPOTBUGS'] = ['com.github.spotbugs:spotbugs-annotations:4.4.0']
	CONFIG['LIBRARY_COMMONS_LANG'] = ['org.apache.commons:commons-lang3:3.12.0', 'commons-io:commons-io:2.6']
	CONFIG['LIBRARY_JNA'] = ['net.java.dev.jna:jna:5.9.0', 'net.java.dev.jna:jna-platform:5.9.0']
	CONFIG['LIBRARY_ECLIPSE_COLLECTION'] = ['org.eclipse.collections:eclipse-collections:10.4.0', 'org.eclipse.collections:eclipse-collections-api:10.4.0']
	CONFIG['LIBRARY_DEPRECATED'] = ['org.apache.httpcomponents:httpclient:4.5.12', 'net.oneandone.reflections8:reflections8:0.11.7', 'org.jogamp.gluegen:gluegen-rt-main:2.3.1', 'org.json:json:20180813', 'org.apache.commons:commons-pool2:2.8.0']
	CONFIG['LIBRARY_DEFAULT'] = CONFIG['LIBRARY_SPOTBUGS'] + CONFIG['LIBRARY_COMMONS_LANG'] + CONFIG['LIBRARY_DEPRECATED'];

	CONFIG['TESTLIBRARY_IMPLEMENTATION'] = 'org.junit.jupiter:junit-jupiter-api:5.7.2'
	CONFIG['TESTLIBRARY_RUNTIME'] = 'org.junit.jupiter:junit-jupiter-engine:5.7.2'

	ext_common_$imported = true
	ext_common_default_group_version = $.&default_group_version
	ext_common_require = $.&require
	ext_common_add_import_action = $.&add_import_action
	ext_common_remove_import_action = $.&remove_import_action
	ext_common$logger_create = logger.&create
	ext_common$logger_available = logger.&available
	ext_common$logger_println_impl = logger.&println_impl
	ext_common$logger_plog = logger.&plog
	ext_common$logger_pinfo = logger.&pinfo
	ext_common$logger_pdebug = logger.&pdebug
	ext_common$logger_pwarn = logger.&pwarn
	ext_common$logger_perror = logger.&perror
	ext_common$logger_destroy = logger.&destroy
	ext_common$utils_as_project = utils.&as_project
	ext_common$utils_as_task = utils.&as_task
	ext_common$utils_forward_task = utils.&forward_task
	ext_common$utils_run_after_another_task = utils.&run_after_another_task
	ext_common$utils_is_single_use_daemon = utils.&is_single_use_daemon
	ext_common$utils_is_running_on_debug = utils.&is_running_on_debug
	ext_common$utils_is_daemon_probably_unstable = utils.&is_daemon_probably_unstable
	require = $.&require
	println_impl = logger.&println_impl
	plog = logger.&plog
	pinfo = logger.&pinfo
	pdebug = logger.&pdebug
	pwarn = logger.&pwarn
	perror = logger.&perror
}

class EXPORT_GLOBAL_FUNCTION {
	def require(def $that, Object... scripts) { return $.require($that, scripts) }
	def println(Object... args) { return logger.println_impl(args) }
	def plog(Object... args) { return logger.plog(args) }
	def pinfo(Object... args) { return logger.pinfo(args) }
	def pdebug(Object... args) { return logger.pdebug(args) }
	def pwarn(Object... args) { return logger.pwarn(args) }
	def perror(Object... args) { return logger.perror(args) }
	def forwardTask(Object project, filter, exec = {}) { return utils.forward_task(project, filter, exec) }
	def runAfterAnotherTask(Object tasks, Object project = null) { return utils.run_after_another_task(tasks, project) }
	def isSingleUseDaemon() { return utils.is_single_use_daemon() }
	def isRunningOnDebug() { return utils.is_running_on_debug() }
	def isDaemonProbablyUnstable() { return utils.is_daemon_probably_unstable() }
}
