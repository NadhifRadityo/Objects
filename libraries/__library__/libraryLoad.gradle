import org.gradle.api.internal.project.DefaultProject

import java.lang.reflect.Method
import java.util.stream.Stream

Map<Integer, LoaderInfo> buildLoader = new HashMap<>()
Integer currentBuildHash

class LoaderInfo {
	boolean accessed
	ClassLoader classLoader
	Class<?> CLASS_Library
	Method METHOD_Library_entry
}
def get_current_loader_info = {
	LoaderInfo loaderInfo = buildLoader.get(currentBuildHash)
	if(loaderInfo != null) return loaderInfo
	throw new IllegalStateException('Build info not available')
}
def clear = { ->
	LoaderInfo loaderInfo = get_current_loader_info()
	loaderInfo.classLoader = null
	loaderInfo.CLASS_Library = null
	loaderInfo.METHOD_Library_entry = null
}
def source_files = { ->
	if(!buildDir.exists()) return new File[0]
	List<File> sourceFiles = new ArrayList<>()
	sourceFiles += sourceSets.main.output.files
	sourceFiles += sourceSets.main.runtimeClasspath.files
	return sourceFiles.toArray(new File[0])
}
def load = { ->
	LoaderInfo loaderInfo = get_current_loader_info()
	if(loaderInfo.classLoader != null) return loaderInfo.classLoader
	URL[] sourceURLs = Stream.of(source_files()).map { it.toURI().toURL() }.toArray(URL[]::new)
	try {
		loaderInfo.classLoader = new URLClassLoader(sourceURLs, $this.project.getClass().getClassLoader())
		loaderInfo.CLASS_Library = loaderInfo.classLoader.loadClass('io.github.NadhifRadityo.Library.LibraryEntry')
		loaderInfo.METHOD_Library_entry = loaderInfo.CLASS_Library.getDeclaredMethod('entry', DefaultProject.class, File.class, Map.class)
		loaderInfo.METHOD_Library_entry.setAccessible(true)
	} catch(Exception e) {
		lerror 'Error while loading library entry point\n', e
	}
	return loaderInfo.classLoader
}
def available = { ->
	LoaderInfo loaderInfo = get_current_loader_info()
	return loaderInfo.METHOD_Library_entry != null
}
def run = { File rootDirectory, Map<String, File> modules ->
	LoaderInfo loaderInfo = get_current_loader_info()
	try {
		loaderInfo.METHOD_Library_entry.invoke(null, $this.project, rootDirectory, modules)
	} catch(Exception e) {
		lerror 'Error while running library entry point\n', e
	}
}
def __default_import_action = { def info ->
	currentBuildHash = null
	if(!containsFlag('export_functions_only')) {
		IncludedBuild build = getScript(info).build
		if(build == null) currentBuildHash = rootDir.getCanonicalPath().hashCode()
		else currentBuildHash = build.projectDir.getCanonicalPath().hashCode()
		LoaderInfo loaderInfo = buildLoader.get(currentBuildHash)
		if(loaderInfo == null) {
			lwarn "New build \"${build != null ? build.name : rootProject.name}\" with hash $currentBuildHash"
			loaderInfo = new LoaderInfo()
			buildLoader.put(currentBuildHash, loaderInfo)
		}
		loaderInfo.accessed = true
	}
}

context(this) {
	scriptApply()
	scriptConstruct {
		addImportAction(buildscript.sourceFile, __default_import_action)
	}
	scriptDestruct {
		removeImportAction(buildscript.sourceFile)
		currentBuildHash = null

		Iterator<Map.Entry<Integer, LoaderInfo>> iterator = buildLoader.entrySet().iterator()
		while(iterator.hasNext()) {
			Map.Entry<Integer, LoaderInfo> entry = iterator.next()
			LoaderInfo loaderInfo = entry.getValue()
			if(loaderInfo.accessed) { loaderInfo.accessed = false; continue }
			lwarn "Removed library loader from build hash ${entry.getKey()}"
			iterator.remove()
		}
	}
}

scriptExport('get_current_loader_info', get_current_loader_info)
scriptExport('clear', clear)
scriptExport('source_files', source_files)
scriptExport('load', load)
scriptExport('available', available)
scriptExport('run', run)
