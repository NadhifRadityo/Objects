import org.gradle.api.internal.project.DefaultProject

import java.lang.reflect.Method
import java.util.stream.Stream

context(this) { require('/common.gradle') }

class $ {
	static def $this
	static Map<Integer, LoaderInfo> buildLoader = new HashMap<>()
	static Integer currentBuildHash

	static class LoaderInfo {
		boolean accessed
		ClassLoader classLoader
		Class<?> CLASS_Library
		Method METHOD_Library_entry
	}
	static LoaderInfo get_current_loader_info() {
		LoaderInfo loaderInfo = buildLoader.get(currentBuildHash)
		if(loaderInfo != null) return loaderInfo
		throw new IllegalStateException('Build info not available')
	}
	static void clear() {
		LoaderInfo loaderInfo = get_current_loader_info()
		loaderInfo.classLoader = null
		loaderInfo.CLASS_Library = null
		loaderInfo.METHOD_Library_entry = null
	}
	static File[] source_files() {
		if(!$this.buildDir.exists()) return new File[0]
		List<File> sourceFiles = new ArrayList<>()
		sourceFiles += $this.sourceSets.main.output.files
		sourceFiles += $this.sourceSets.main.runtimeClasspath.files
		return sourceFiles.toArray(new File[0])
	}
	static ClassLoader load() {
		LoaderInfo loaderInfo = get_current_loader_info()
		if(loaderInfo.classLoader != null) return loaderInfo.classLoader
		URL[] sourceURLs = Stream.of(source_files()).map { it.toURI().toURL() }.toArray(URL[]::new)
		try {
			loaderInfo.classLoader = new URLClassLoader(sourceURLs, $this.project.getClass().getClassLoader())
			loaderInfo.CLASS_Library = loaderInfo.classLoader.loadClass('io.github.NadhifRadityo.Library.LibraryEntry')
			loaderInfo.METHOD_Library_entry = loaderInfo.CLASS_Library.getDeclaredMethod('entry', DefaultProject.class, File.class, Map.class)
			loaderInfo.METHOD_Library_entry.setAccessible(true)
		} catch(Exception e) {
			$this.perror 'Error while loading library entry point\n', e
		}
		return loaderInfo.classLoader
	}
	static boolean available() {
		LoaderInfo loaderInfo = get_current_loader_info()
		return loaderInfo.METHOD_Library_entry != null
	}
	static void run(File rootDirectory, Map<String, File> modules) {
		LoaderInfo loaderInfo = get_current_loader_info()
		try {
			loaderInfo.METHOD_Library_entry.invoke(null, $this.project, rootDirectory, modules)
		} catch(Exception e) {
			$this.perror 'Error while running library entry point\n', e
		}
	}
	static void __default_import_action(def info) {
		def $that = info.importContext
		currentBuildHash = null
		if(!$that.contains_flag('export_functions_only')) {
			IncludedBuild build = info.build
			if(build == null) currentBuildHash = $that.rootDir.getCanonicalPath().hashCode()
			else currentBuildHash = build.projectDir.getCanonicalPath().hashCode()
			LoaderInfo loaderInfo = buildLoader.get(currentBuildHash)
			if(loaderInfo == null) {
				$this.pwarn "New build \"${build != null ? build.name : $that.rootProject.name}\" with hash $currentBuildHash"
				loaderInfo = new LoaderInfo()
				buildLoader.put(currentBuildHash, loaderInfo)
			}
			loaderInfo.accessed = true
		}
	}
}
context(this) {
	scriptApply()
	scriptInit {
		$.$this = this
		ext_common_add_import_action(buildscript.sourceFile, $.&__default_import_action)
	}
	scriptDeinit {
		plog new Error()
		$.$this = null
		$.currentBuildHash = null
		ext_common_remove_import_action(buildscript.sourceFile)
		Iterator<Map.Entry<Integer, $.LoaderInfo>> iterator = $.buildLoader.entrySet().iterator()
		while(iterator.hasNext()) {
			Map.Entry<Integer, $.LoaderInfo> entry = iterator.next()
			$.LoaderInfo loaderInfo = entry.getValue()
			if(loaderInfo.accessed) { loaderInfo.accessed = false; continue }
			pwarn "Removed library loader from build hash ${entry.getKey()}"
			iterator.remove()
		}
	}
}

export('ext_libraryLoad_get_current_loader_info', $.&get_current_loader_info)
export('ext_libraryLoad_clear', $.&clear)
export('ext_libraryLoad_source_files', $.&source_files)
export('ext_libraryLoad_load', $.&load)
export('ext_libraryLoad_available', $.&available)
export('ext_libraryLoad_run', $.&run)
