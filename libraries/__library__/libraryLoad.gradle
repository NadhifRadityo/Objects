import java.lang.reflect.Method
import java.util.stream.Stream

context(this) {
	scriptImport from('/std$ClassUtils'), being('classUtils')
}

def memory
Map<Integer, LoaderInfo> buildLoader
Integer currentBuildHash

class LoaderInfo {
	boolean accessed
	ClassLoader classLoader
	Class<?> CLASS_Library
	Method METHOD_Library_entry
}
def get_current_loader_info = {
	LoaderInfo loaderInfo = buildLoader.get(currentBuildHash)
	if(loaderInfo != null) return loaderInfo
	throw new IllegalStateException('Build info not available')
}
def clear = { ->
	LoaderInfo loaderInfo = get_current_loader_info()
	loaderInfo.classLoader = null
	loaderInfo.CLASS_Library = null
	loaderInfo.METHOD_Library_entry = null
}
def source_files = { ->
	if(!buildDir.exists()) return new File[0]
	List<File> sourceFiles = new ArrayList<>()
	sourceFiles += sourceSets.main.output.files
	sourceFiles += sourceSets.main.runtimeClasspath.files
	return sourceFiles.toArray(new File[0])
}
def load = { ->
	LoaderInfo loaderInfo = get_current_loader_info()
	if(loaderInfo.classLoader != null) return loaderInfo.classLoader
	URL[] sourceURLs = Stream.of(source_files()).map { it.toURI().toURL() }.toArray(URL[]::new)
	try {
		loaderInfo.classLoader = new URLClassLoader(sourceURLs, classUtils.defaultClassLoader)
		loaderInfo.CLASS_Library = loaderInfo.classLoader.loadClass('io.github.NadhifRadityo.Library.LibraryEntry')
		loaderInfo.METHOD_Library_entry = loaderInfo.CLASS_Library.getDeclaredMethod('entry', classUtils.classForName0('Gradle.Context'), File.class, Map.class)
		loaderInfo.METHOD_Library_entry.setAccessible(true)
	} catch(Exception e) {
		lerror 'Error while loading library entry point\n', e
	}
	return loaderInfo.classLoader
}
def available = { ->
	LoaderInfo loaderInfo = get_current_loader_info()
	return loaderInfo.METHOD_Library_entry != null
}
def run = { def context, File rootDirectory, Map<String, File> modules ->
	LoaderInfo loaderInfo = get_current_loader_info()
	try {
		loaderInfo.METHOD_Library_entry.invoke(null, context, rootDirectory, modules)
	} catch(Exception e) {
		lerror 'Error while running library entry point\n', e
	}
}
def __default_import_action = { def info ->
	if(!containsFlag('export_functions_only')) {
		Project project = info.context.project.rootProject
		currentBuildHash = project.rootDir.hashCode()
		LoaderInfo loaderInfo = buildLoader.get(currentBuildHash)
		if(loaderInfo == null) {
			llog "New build \"${project.name}\" at path \"${project.rootDir}\" with hash $currentBuildHash"
			loaderInfo = new LoaderInfo()
			buildLoader.put(currentBuildHash, loaderInfo)
		}
		loaderInfo.accessed = true
	}
}

context(this) {
	scriptApply()
	scriptConstruct {
		addImportAction(buildscript.sourceFile, __default_import_action)
		memory = persistentMemory()
		buildLoader = memory.getOrCompute('buildLoader') { new HashMap() }
		currentBuildHash = null
	}
	scriptDestruct {
		removeImportAction(buildscript.sourceFile)
		Iterator<Map.Entry<Integer, LoaderInfo>> iterator = buildLoader.entrySet().iterator()
		while(iterator.hasNext()) {
			Map.Entry<Integer, LoaderInfo> entry = iterator.next()
			LoaderInfo loaderInfo = entry.getValue()
			if(loaderInfo.accessed) { loaderInfo.accessed = false; continue }
			llog "Removed library loader from build hash ${entry.getKey()}"
			iterator.remove()
		}
		memory = null
		buildLoader = null
		currentBuildHash = null
	}
}

scriptExport get_current_loader_info, being('get_current_loader_info')
scriptExport clear, being('clear')
scriptExport source_files, being('source_files')
scriptExport load, being('load')
scriptExport available, being('available')
scriptExport run, being('run')
