import java.nio.file.Path
import java.nio.file.Files

Map<String, File> loadedModules = new HashMap<>()
File relativeToDir
File librariesDir

def set_relative_to_dir = { File relativeToDir0 ->
	relativeToDir = relativeToDir0
	if(relativeToDir == buildscript.sourceFile.parentFile) return
	Path target = new File(buildscript.sourceFile.parentFile, 'src').toPath()
	Path link = new File(relativeToDir, 'src').toPath()
	if(Files.isSymbolicLink(link) && Files.readSymbolicLink(link).toAbsolutePath() == target.toAbsolutePath())
		return
	Files.deleteIfExists(link)
	try { Files.createSymbolicLink(link, target) } catch(Throwable ignored) { }
	if(Files.exists(link)) return
	lwarn 'Cannot create library junction, reverting to use srcDirs alternative. Your IDE might not like this because modules cannot share the same content root.'
	lwarn 'If you have problem with this alternative, try to elevate either gradle or your IDE as administrator.'
	String sourcePath = getRelativeFile(relativeToDir, target.resolve('main').toFile()).getPath()
	sourceSets {
		main.java { srcDirs = [ "$sourcePath/java" ] }
		main.kotlin { srcDirs = [ "$sourcePath/kotlin" ] }
		main.resources { srcDirs = [ "$sourcePath/resources" ] }
	}
}
def set_libraries_dir = { File librariesDir0 ->
	librariesDir = librariesDir0
}
def root_directory = { ->
	return getRelativeFile(new File(System.getProperty('user.dir')), librariesDir)
}
def module = { String path ->
	String moduleIdentifier = path.toLowerCase().replaceAll('[^A-Za-z0-9]', '_')
	File modulePath = new File(root_directory(), path)
	if(loadedModules.containsKey(moduleIdentifier)) {
		lwarn "Library module '$path' has the same identifier"
		return
	}
	linfo "Imported library module '$path'"
	loadedModules.put(moduleIdentifier, modulePath)
	String sourcePath = getRelativeFile(relativeToDir, modulePath).getPath()
	sourceSets {
		main.java { srcDir "$sourcePath/java" }
		main.kotlin { srcDir "$sourcePath/kotlin" }
		main.resources { srcDir "$sourcePath/resources" }
	}
}
def loaded_modules = { ->
	return Collections.unmodifiableMap(loadedModules)
}
def __default_import_action = { def info ->
	if(!containsFlag('dont_clear_last_state')) {
		loadedModules.clear()
		relativeToDir = null
		librariesDir = null
	}
	if(!containsFlag('export_functions_only') && !containsFlag('dont_clear_last_state')) {
		set_relative_to_dir(buildscript.sourceFile.parentFile as File)
		set_libraries_dir(buildscript.sourceFile.parentFile.parentFile as File)
	}
}

context(this) {
	scriptApply()
	scriptConstruct {
		addImportAction(buildscript.sourceFile, __default_import_action)
	}
	scriptDestruct {
		removeImportAction(buildscript.sourceFile)
		relativeToDir = null
		librariesDir = null
	}
}

scriptExport('set_relative_to_dir', set_relative_to_dir)
scriptExport('set_libraries_dir', set_libraries_dir)
scriptExport('root_directory', root_directory)
scriptExport('module', module)
scriptExport('loaded_modules', loaded_modules)
