import java.nio.file.Path
import java.nio.file.Files

context(this) {
	scriptImport listOf('fileRelative'), from('/std$FileUtils')
}

Map<String, File> loadedModules = new HashMap<>()
File relativeToDir
File librariesDir

def applySourceSets = { String sourcePath ->
	delegate.sourceSets {
		main.java { srcDir "$sourcePath/java" }
		main.kotlin { srcDir "$sourcePath/kotlin" }
		main.resources { srcDir "$sourcePath/resources" }
	}
}
def set_relative_to_dir = { File relativeToDir0 ->
	relativeToDir = relativeToDir0
	if(relativeToDir == buildscript.sourceFile.parentFile) return
	Path target = new File(buildscript.sourceFile.parentFile, 'src').toPath()
	Path link = new File(relativeToDir, 'src').toPath()
	if(Files.isSymbolicLink(link) && Files.readSymbolicLink(link).toAbsolutePath() == target.toAbsolutePath())
		return
	Files.deleteIfExists(link)
	try { Files.createSymbolicLink(link, target) } catch(Throwable ignored) { }
	if(Files.exists(link)) return
	lwarn 'Cannot create library junction, reverting to use srcDirs alternative. Your IDE might not like this because modules cannot share the same content root.'
	lwarn 'If you have problem with this alternative, try to elevate either gradle or your IDE as administrator.'
	String sourcePath = fileRelative(relativeToDir, target.resolve('main').toFile())
	sourceSets {
		main.java { srcDirs = [ "$sourcePath/java" ] }
		main.kotlin { srcDirs = [ "$sourcePath/kotlin" ] }
		main.resources { srcDirs = [ "$sourcePath/resources" ] }
	}
}
def set_libraries_dir = { File librariesDir0 ->
	librariesDir = librariesDir0
}
def root_directory = { ->
	return fileRelative(new File(System.getProperty('user.dir')), librariesDir)
}
def module = { String path ->
	String moduleIdentifier = path.toLowerCase().replaceAll('[^A-Za-z0-9]', '_')
	File modulePath = new File(root_directory(), path)
	if(loadedModules.containsKey(moduleIdentifier)) {
		lwarn "Library module '$path' has the same identifier"
		return
	}
	linfo "Imported library module '$path'"
	loadedModules.put(moduleIdentifier, modulePath)
	String sourcePath = fileRelative(relativeToDir, modulePath)
	applySourceSets(sourcePath)
}
def loaded_modules = { ->
	return Collections.unmodifiableMap(loadedModules)
}
def __default_import_action = { def info ->
	if(!containsFlag('dont_clear_last_state')) {
		loadedModules.clear()
		relativeToDir = null
		librariesDir = null
		applySourceSets.delegate = null
	}
	if(!containsFlag('export_functions_only') && !containsFlag('dont_clear_last_state')) {
		Project project = info.context.project
		set_relative_to_dir(project.buildscript.sourceFile.parentFile as File)
		set_libraries_dir(project.buildscript.sourceFile.parentFile.parentFile as File)
		applySourceSets.delegate = project
	}
}

context(this) {
	scriptApply()
	scriptConstruct {
		addImportAction(buildscript.sourceFile, __default_import_action)
		applySourceSets.delegate = null
	}
	scriptDestruct {
		removeImportAction(buildscript.sourceFile)
		loadedModules.clear()
		relativeToDir = null
		librariesDir = null
		applySourceSets.delegate = null
	}
}

scriptExport set_relative_to_dir, being('set_relative_to_dir')
scriptExport set_libraries_dir, being('set_libraries_dir')
scriptExport root_directory, being('root_directory')
scriptExport module, being('module')
scriptExport loaded_modules, being('loaded_modules')
